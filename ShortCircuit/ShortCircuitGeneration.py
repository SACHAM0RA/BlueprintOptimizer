from typing import List
from enum import Enum
import re

pin_counter = 0
BASE_DISTANCE_X = 300
BASE_DISTANCE_Y = 100


def getPinCounter():
    global pin_counter
    pin_counter += 1
    return str(pin_counter).zfill(32)


BRANCH_TEMPLATE = \
    '''Begin Object Class=/Script/BlueprintGraph.K2Node_IfThenElse Name="{NODE_NAME}" ExportPath=/Script/BlueprintGraph.K2Node_IfThenElse'"/Game/SomeProject/Logic/EntitySystem/EntityTypes/Structures/SomeBlueprint.SomeBlueprint:SomeFunction.{NODE_NAME}"'
   NodePosX={POS_X}
   NodePosY={POS_Y}
   NodeGuid={NODE_ID}
   CustomProperties Pin (PinId={EXEC_PIN_ID},PinName="execute",PinType.PinCategory="exec",PinType.PinSubCategory="",PinType.PinSubCategoryObject=None,PinType.PinSubCategoryMemberReference=(),PinType.PinValueType=(),PinType.ContainerType=None,PinType.bIsReference=False,PinType.bIsConst=False,PinType.bIsWeakPointer=False,PinType.bIsUObjectWrapper=False,PinType.bSerializeAsSinglePrecisionFloat=False,LinkedTo=({EXEC_LINK}),PersistentGuid=00000000000000000000000000000000,bHidden=False,bNotConnectable=False,bDefaultValueIsReadOnly=False,bDefaultValueIsIgnored=False,bAdvancedView=False,bOrphanedPin=False,)
   CustomProperties Pin (PinId={COND_PIN_ID},PinName="Condition",PinType.PinCategory="bool",PinType.PinSubCategory="",PinType.PinSubCategoryObject=None,PinType.PinSubCategoryMemberReference=(),PinType.PinValueType=(),PinType.ContainerType=None,PinType.bIsReference=False,PinType.bIsConst=False,PinType.bIsWeakPointer=False,PinType.bIsUObjectWrapper=False,PinType.bSerializeAsSinglePrecisionFloat=False,DefaultValue="true",AutogeneratedDefaultValue="true",LinkedTo=({COND_LINK}),PersistentGuid=00000000000000000000000000000000,bHidden=False,bNotConnectable=False,bDefaultValueIsReadOnly=False,bDefaultValueIsIgnored=False,bAdvancedView=False,bOrphanedPin=False,)
   CustomProperties Pin (PinId={THEN_PIN_ID},PinName="then",PinFriendlyName=NSLOCTEXT("K2Node", "true", "true"),Direction="EGPD_Output",PinType.PinCategory="exec",PinType.PinSubCategory="",PinType.PinSubCategoryObject=None,PinType.PinSubCategoryMemberReference=(),PinType.PinValueType=(),PinType.ContainerType=None,PinType.bIsReference=False,PinType.bIsConst=False,PinType.bIsWeakPointer=False,PinType.bIsUObjectWrapper=False,PinType.bSerializeAsSinglePrecisionFloat=False,LinkedTo=({THEN_LINK}),PersistentGuid=00000000000000000000000000000000,bHidden=False,bNotConnectable=False,bDefaultValueIsReadOnly=False,bDefaultValueIsIgnored=False,bAdvancedView=False,bOrphanedPin=False,)
   CustomProperties Pin (PinId={ELSE_PIN_ID},PinName="else",PinFriendlyName=NSLOCTEXT("K2Node", "false", "false"),Direction="EGPD_Output",PinType.PinCategory="exec",PinType.PinSubCategory="",PinType.PinSubCategoryObject=None,PinType.PinSubCategoryMemberReference=(),PinType.PinValueType=(),PinType.ContainerType=None,PinType.bIsReference=False,PinType.bIsConst=False,PinType.bIsWeakPointer=False,PinType.bIsUObjectWrapper=False,PinType.bSerializeAsSinglePrecisionFloat=False,LinkedTo=({ELSE_LINK}),PersistentGuid=00000000000000000000000000000000,bHidden=False,bNotConnectable=False,bDefaultValueIsReadOnly=False,bDefaultValueIsIgnored=False,bAdvancedView=False,bOrphanedPin=False,)
End Object'''


########################################
############### HELPERS ################
########################################

def extractStringBetween(text, start_substring, end_substring):
    # Create a regular expression pattern to match the substring between the start and end substrings
    pattern = re.compile(fr"{re.escape(start_substring)}(.*?){re.escape(end_substring)}")

    # Use the re.search method to find a match
    match = pattern.search(text)

    if match:
        extracted_string: str = match.group(1)
        return extracted_string
    else:
        return ""


def matchStartAndEnd(text, start_substring, end_substring):
    # Create a regular expression pattern to match the string
    pattern = re.compile(fr"^{re.escape(start_substring)}.*{re.escape(end_substring)}$")

    # Use the re.search method to find a match
    match = pattern.search(text)

    if match:
        matched_string: str = match.group()
        return matched_string
    else:
        return ""


def findAllSubString(text, substring):
    returnList = []
    start = 0
    while start < len(text):
        index = text.find(substring, start)
        if index == -1:
            break
        returnList.append(index)
        start = index + 1
    return returnList


########################################
############### CLASSES ################
########################################

class PinType(Enum):
    EXEC = 0
    BOOl = 1
    OTHER = 3


class PinDirection(Enum):
    IN = 0
    OUT = 1


class ObjectPin(object):
    def __init__(self, stringData: str, source):
        self.content = ""
        self.id = ""
        self.linkSection = ""
        self.linkElementName = ""
        self.linkID = ""
        self.type = PinType.OTHER
        self.direction = PinDirection.IN
        self.source: ObjectElement = source

        self.content = stringData
        if self.content == "":
            return
        self.id = extractStringBetween(self.content, "PinId=", ",")
        self.linkSection = extractStringBetween(self.content, "LinkedTo=(", "),")
        if self.linkSection != "":
            self.linkElementName = self.linkSection.split(" ")[0]
            self.linkID = self.linkSection.split(" ")[1]
            self.linkID = self.linkID.split(",")[0]

        if self.content.find('PinType.PinCategory="exec"') != -1:
            self.type = PinType.EXEC
        else:
            if self.content.find('PinType.PinCategory="bool"') != -1:
                self.type = PinType.BOOl
            else:
                self.type = PinType.OTHER

        if self.content.find('Direction="EGPD_Output"') != -1:
            self.direction = PinDirection.OUT
        else:
            self.direction = PinDirection.IN

    def __str__(self):
        return extractStringBetween(self.content, 'PinName="', '",')

    def __repr__(self):
        return extractStringBetween(self.content, 'PinName="', '",')

    def isConnectedTo(self, otherPin, otherElement):
        return (self.linkID == otherPin.id) and (self.linkElementName == str(otherElement))

    def getSink(self):
        return self.source.findPinSink(self)


class ElementType(Enum):
    BRANCH = 0
    AND_OPERATOR = 1
    OR_OPERATOR = 2
    BOOL_VARIABLE = 3
    PURE_FUNCTION = 4
    OTHER = 5


class ObjectElement(object):
    def __init__(self, stringData: str):
        self.content = stringData
        self.connectionsByData = []
        self.connectionsByFlow = []
        self.conditionElement: ObjectElement

        self.type = ElementType.OTHER
        self.fillType()

        self.pins: List[ObjectPin] = []
        self.conditionPin = ObjectPin
        self.execPin: ObjectPin
        self.thenPin: ObjectPin
        self.elsePin: ObjectPin
        self.fillPins()

    def __str__(self):
        return extractStringBetween(self.content, 'Name="', '" ')

    def __repr__(self):
        return extractStringBetween(self.content, 'Name="', '" ')

    def isValid(self):
        return self.content != ""

    def fillPins(self):
        self.pins.clear()
        indices = findAllSubString(self.content, "CustomProperties Pin ")
        for index in indices:
            line_start = self.content.rfind('\n', 0, index) + 1
            line_end = self.content.find('\n', index)
            if line_end == -1:
                line_end = len(self.content)
            line = self.content[line_start:line_end]
            pin = ObjectPin(line, self)
            self.pins.append(pin)

            if str(pin) == "execute":
                self.execPin = pin
            if str(pin) == "then":
                self.thenPin = pin
            if str(pin) == "else":
                self.elsePin = pin
            if str(pin) == "Condition":
                self.conditionPin = pin

    def fillType(self):
        if "Class=/Script/BlueprintGraph.K2Node_IfThenElse" in self.content:
            self.type = ElementType.BRANCH
            return

        if 'MemberName="BooleanAND"' in self.content:
            self.type = ElementType.AND_OPERATOR
            return

        if 'MemberName="BooleanOR"' in self.content:
            self.type = ElementType.OR_OPERATOR
            return

        if "Class=/Script/BlueprintGraph.K2Node_VariableGet" in self.content:
            if 'PinType.PinCategory="bool"' in self.content:
                self.type = ElementType.BOOL_VARIABLE
                return

        if self.content.find("bIsPureFunc=True"):
            self.type = ElementType.PURE_FUNCTION
            return

        self.type = ElementType.OTHER

    def isConnectedByFlowTo(self, otherElement):
        for pin in self.pins:
            if pin.type == PinType.EXEC:
                for o_pin in otherElement.pins:
                    if pin.isConnectedTo(o_pin, otherElement):
                        return True, pin, o_pin
        return False, None, None

    def isConnectedByDataTo(self, otherElement):
        for pin in self.pins:
            if pin.type != PinType.EXEC:
                for o_pin in otherElement.pins:
                    if pin.isConnectedTo(o_pin, otherElement):
                        return True, pin, o_pin
        return False, None, None

    def fillConnectionsByFlow(self, allElements: List):
        self.connectionsByFlow.clear()
        for other in allElements:
            (success, pin, otherPin) = self.isConnectedByFlowTo(other)
            if success:
                self.connectionsByFlow.append((other, pin, otherPin))

    def fillConnectionsByData(self, allElements: List):
        self.connectionsByData.clear()
        for other in allElements:
            (success, pin, otherPin) = self.isConnectedByDataTo(other)
            if success:
                self.connectionsByData.append((other, pin, otherPin))
                if self.type == ElementType.BRANCH:
                    self.conditionElement = (other, pin, otherPin)

    def findPinSink(self, pin: ObjectPin):
        for connection in self.connectionsByData:
            if connection[1] == pin:
                return connection[0]

        for connection in self.connectionsByFlow:
            if connection[1] == pin:
                return connection[0]

        return ObjectElement("")

    def getLocation(self) -> (int, int):
        if not self.isValid():
            return 0, 0

        X_str = extractStringBetween(self.content, "NodePosX=", "\n")
        X = int(X_str)

        Y_str = extractStringBetween(self.content, "NodePosY=", "\n")
        Y = int(Y_str)

        return [X, Y]

    def move(self, deltaX: int, deltaY: int):
        if not self.isValid():
            return

        X_str = extractStringBetween(self.content, "NodePosX=", "\n")
        X: int = int(X_str)
        currentX = "NodePosX=" + X_str
        self.content = self.content.replace(currentX, "NodePosX=" + str(X + deltaX))

        Y_str = extractStringBetween(self.content, "NodePosY=", "\n")
        Y = int(Y_str)
        currentY = "NodePosY=" + Y_str
        self.content = self.content.replace(currentY, "NodePosY=" + str(Y + deltaY))

    def moveAndPropagate(self, deltaX: int, deltaY: int):
        if not self.isValid():
            return

        self.move(deltaX, deltaY)
        for pin in self.pins:
            if (pin.type == PinType.BOOl and pin.direction == PinDirection.IN) or \
                    (pin.type == PinType.OTHER and pin.direction == PinDirection.IN) or \
                    (pin.type == PinType.EXEC and pin.direction == PinDirection.OUT):
                pin.getSink().moveAndPropagate(deltaX, deltaY)

    def moveToAndPropagate(self, X: int, Y: int):
        currentLocation = self.getLocation()
        delta = X - currentLocation[0], Y - currentLocation[1]
        self.moveAndPropagate(delta[0], delta[1])


class BranchFactory(object):
    def __init__(self):
        self.nodeName: str = ""
        self.nodeID: str = ""
        self.execPinID: str = ""
        self.condPinID: str = ""
        self.thenPinID: str = ""
        self.elsePinID: str = ""
        self.execLinkData: str = ""
        self.condLinkData: str = ""
        self.thenLinkData: str = ""
        self.elseLinkData: str = ""
        self.pos = [0, 0]

    def generateContent(self) -> str:
        bp_content = BRANCH_TEMPLATE

        bp_content = bp_content.replace("{NODE_NAME}", self.nodeName)
        bp_content = bp_content.replace("{NODE_ID}", self.nodeID)

        bp_content = bp_content.replace("{EXEC_PIN_ID}", self.execPinID)
        bp_content = bp_content.replace("{COND_PIN_ID}", self.condPinID)
        bp_content = bp_content.replace("{THEN_PIN_ID}", self.thenPinID)
        bp_content = bp_content.replace("{ELSE_PIN_ID}", self.elsePinID)

        bp_content = bp_content.replace("{EXEC_LINK}", self.execLinkData)
        bp_content = bp_content.replace("{COND_LINK}", self.condLinkData)
        bp_content = bp_content.replace("{THEN_LINK}", self.thenLinkData)
        bp_content = bp_content.replace("{ELSE_LINK}", self.elseLinkData)

        bp_content = bp_content.replace("{POS_X}", str(self.pos[0]))
        bp_content = bp_content.replace("{POS_Y}", str(self.pos[1]))
        return bp_content


########################################
################# MAIN #################
########################################
def syncConnections(elements):
    for element in elements:
        element.fillPins()

    for element in elements:
        element.fillConnectionsByData(elements)
        element.fillConnectionsByFlow(elements)


def findBranchesAmongElements(allElements):
    branches = []
    for elem in allElements:
        if elem.type == ElementType.BRANCH:
            branches.append(elem)
    return branches


def expandBranchForAnd(branch: ObjectElement, allElements: List[ObjectElement]) -> List[ObjectElement]:
    factories: List[BranchFactory] = []
    logicOp: ObjectElement = branch.conditionElement[0]
    connection_counter = 0
    baseLocation = [0, 0]
    for connection in logicOp.connectionsByData:
        if connection[0].type != ElementType.BRANCH:
            f = BranchFactory()
            f.nodeName = str(branch) + "_" + str(connection_counter)
            f.nodeID = getPinCounter()
            f.execPinID = getPinCounter()
            f.condPinID = getPinCounter()
            f.thenPinID = getPinCounter()
            f.elsePinID = getPinCounter()

            if connection_counter == 0:
                f.execLinkData = branch.execPin.linkSection
                baseLocation = branch.getLocation()
                f.pos = baseLocation
            else:
                f.execLinkData = factories[-1].nodeName + " " + factories[-1].thenPinID
                baseLocation = baseLocation[0] + BASE_DISTANCE_X, baseLocation[1] - BASE_DISTANCE_Y
                f.pos = baseLocation

            if connection_counter > 0:
                factories[-1].thenLinkData = f.nodeName + " " + f.execPinID

            f.condLinkData = connection[1].linkSection
            f.elseLinkData = branch.elsePin.linkSection

            oldLink = str(logicOp) + " " + connection[1].id
            newLink = f.nodeName + " " + f.condPinID
            connection[0].content = connection[0].content.replace(oldLink, newLink)
            connection[0].moveToAndPropagate(f.pos[0], f.pos[1] + 100)

            factories.append(f)
            connection_counter += 1

    factories[-1].thenLinkData = branch.thenPin.linkSection

    expansion: List[ObjectElement] = []
    for f in factories:
        new_content = f.generateContent()
        expansion.append(ObjectElement(stringData=new_content))

    if len(expansion) > 0:
        allElements.remove(branch)
        allElements.remove(branch.conditionElement[0])
        allElements.extend(expansion)
        syncConnections(allElements)

        targetThenLocation = factories[-1].pos[0] + BASE_DISTANCE_X, factories[-1].pos[1] - BASE_DISTANCE_Y
        branch.thenPin.getSink().moveToAndPropagate(targetThenLocation[0], targetThenLocation[1])

        targetElseLocation = factories[-1].pos[0] + BASE_DISTANCE_X, factories[0].pos[1] + BASE_DISTANCE_Y * (
                    connection_counter + 1)
        branch.elsePin.getSink().moveToAndPropagate(targetElseLocation[0], targetElseLocation[1])

    return expansion


def expandBranchForOr(branch: ObjectElement, allElements: List[ObjectElement]) -> List[ObjectElement]:
    factories: List[BranchFactory] = []
    logicOp: ObjectElement = branch.conditionElement[0]
    connection_counter = 0
    baseLocation = [0, 0]
    for connection in logicOp.connectionsByData:
        if connection[0].type != ElementType.BRANCH:
            f = BranchFactory()
            f.nodeName = str(branch) + "_" + str(connection_counter)
            f.nodeID = getPinCounter()
            f.execPinID = getPinCounter()
            f.condPinID = getPinCounter()
            f.thenPinID = getPinCounter()
            f.elsePinID = getPinCounter()

            if connection_counter == 0:
                f.execLinkData = branch.execPin.linkSection
                baseLocation = branch.getLocation()
                f.pos = baseLocation
            else:
                f.execLinkData = factories[-1].nodeName + " " + factories[-1].elsePinID
                baseLocation = baseLocation[0] + BASE_DISTANCE_X, baseLocation[1] + BASE_DISTANCE_Y
                f.pos = baseLocation

            if connection_counter > 0:
                factories[-1].elseLinkData = f.nodeName + " " + f.execPinID

            f.condLinkData = connection[1].linkSection
            f.thenLinkData = branch.thenPin.linkSection

            oldLink = str(logicOp) + " " + connection[1].id
            newLink = f.nodeName + " " + f.condPinID
            connection[0].content = connection[0].content.replace(oldLink, newLink)
            connection[0].moveToAndPropagate(f.pos[0], f.pos[1] + 100)

            factories.append(f)
            connection_counter += 1

    factories[-1].elseLinkData = branch.elsePin.linkSection

    expansion: List[ObjectElement] = []
    for f in factories:
        new_content = f.generateContent()
        expansion.append(ObjectElement(stringData=new_content))

    if len(expansion) > 0:
        allElements.remove(branch)
        allElements.remove(branch.conditionElement[0])
        allElements.extend(expansion)
        syncConnections(allElements)

        targetThenLocation = factories[-1].pos[0] + BASE_DISTANCE_X, factories[0].pos[1] - BASE_DISTANCE_Y * (
                    connection_counter + 1)
        branch.thenPin.getSink().moveToAndPropagate(targetThenLocation[0], targetThenLocation[1])

        targetElseLocation = factories[-1].pos[0] + BASE_DISTANCE_X, factories[-1].pos[1] + BASE_DISTANCE_Y
        branch.elsePin.getSink().moveToAndPropagate(targetElseLocation[0], targetElseLocation[1])

    return expansion


def expandBranch(branch: ObjectElement, allElements: List[ObjectElement]) -> List[ObjectElement]:
    if branch.type != ElementType.BRANCH:
        return []
    logicOp = branch.conditionElement
    if logicOp[0].type == ElementType.AND_OPERATOR:
        return expandBranchForAnd(branch, allElements)
    if logicOp[0].type == ElementType.OR_OPERATOR:
        return expandBranchForOr(branch, allElements)
    return []


with open('SampleBlueprint_1', 'r') as file:
    file_contents = file.read()

file_contents = file_contents.replace("End Object", "End Object####")
contents = file_contents.split("####")[:-1]

elements: List[ObjectElement] = []
for content in contents:
    elements.append(ObjectElement(stringData=content))

syncConnections(elements)

branches = findBranchesAmongElements(elements)
while len(branches) > 0:
    branch = branches.pop(-1)
    expansion: List[ObjectElement] = expandBranch(branch, elements)
    branches.extend(expansion)

newCode: str = ""
for element in elements:
    newCode = newCode + '\n' + element.content

print(newCode)
